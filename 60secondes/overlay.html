<!DOCTYPE html>
<html lang="fr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, initial-scale=1.0">
    <title>60 Secondes - Overlay OBS</title>
    <link rel="icon"
          href="assets/icon.png"
          type="image/x-icon">

    <!-- Firebase SDK -->
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-app-compat.js"></script>
    <script src="https://www.gstatic.com/firebasejs/10.7.1/firebase-database-compat.js"></script>

    <script src="firebase-config.js"></script>
    <script src="config.js"></script>

    <style>
        @font-face {
            font-family: 'Poppins';
            src: url('assets/Poppins-Regular.ttf') format('truetype');
            font-weight: 400;
            font-style: normal;
        }

        @font-face {
            font-family: 'AzeretMono';
            src: url('assets/AzeretMono-VariableFont_wght.ttf') format('truetype');
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            height: 100vh;
            margin: 0;
            font-family: 'Poppins', Arial, Helvetica, sans-serif;
            text-align: center;
            color: white;
            overflow: hidden;
            background: transparent;
        }

        /* Wrapper 16:9 avec bordure animée */
        .ratio-wrapper {
            width: 100%;
            position: relative;
            padding-top: 56.25%;
            /* Ratio 16:9 */
            box-sizing: border-box;
        }

        /* Image de fond pour la zone 16:9 */
        .ratio-wrapper::before {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image: url('assets/Fond.png');
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0;
            transition: opacity 0.5s ease;
            z-index: 0;
            pointer-events: none;
        }

        .ratio-wrapper.show-background::before {
            opacity: 1;
        }

        /* Bordure SVG progressive */
        .progress-border-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            transition: opacity 0.8s ease-out;
        }

        .progress-border-svg rect {
            fill: none;
            stroke-width: 4;
            stroke-linecap: butt;
            stroke-linejoin: miter;
            transition: stroke 0.6s ease-out, opacity 0.3s ease;
        }

        .progress-border-svg stop {
            transition: stop-color 0.6s ease-out;
        }

        .progress-border-svg rect.overtime {
            animation: borderFade 0.6s ease-in-out infinite !important;
        }

        .progress-border-svg {
            opacity: 1 !important;
        }

        .progress-border-svg.fade-out {
            opacity: 0.15;
        }

        @keyframes borderFade {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.05;
            }
        }

        @keyframes blinkAll {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.2;
            }
        }

        .blink-mode {
            animation: blinkAll 0.8s ease-in-out infinite !important;
        }

        /* Zone 16:9 pour le contenu principal */
        .main-content {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* Dégradé animé avec vagues fluides */
        .waves-container {
            z-index: 0;
            position: absolute;
            inset: 0;
            overflow: hidden;
            pointer-events: none;
        }

        .gradient {
            --size: 300px;
            --speed: 28s;
            --start-x: 0vw;
            --start-y: 0vh;
            --end-x: 0vw;
            --end-y: 0vh;
            --rotation: 0deg;
            position: absolute;
            top: 50%;
            left: 50%;
            width: var(--size);
            height: var(--size);
            margin-left: calc(var(--size) / -2);
            margin-top: calc(var(--size) / -2);
            filter: blur(15px);
            background-image: linear-gradient(45deg, hsl(270, 80%, 50%), hsl(290, 70%, 60%));
            animation: randomFloat var(--speed) ease-in-out infinite;
            border-radius: 50%;
            opacity: 0.12;
            will-change: transform;
            transform: translateZ(0);
            backface-visibility: hidden;
            pointer-events: none;
        }

        .gradient:nth-child(2) {
            --size: 280px;
            --speed: 35s;
            background-image: linear-gradient(135deg, hsl(280, 75%, 55%), hsl(260, 85%, 45%));
        }

        .gradient:nth-child(3) {
            --size: 320px;
            --speed: 32s;
            background-image: linear-gradient(225deg, hsl(275, 70%, 50%), hsl(285, 75%, 60%));
        }

        @keyframes randomFloat {
            0% {
                transform: translate(var(--start-x), var(--start-y)) rotate(0deg) translateZ(0);
            }

            50% {
                transform: translate(var(--end-x), var(--end-y)) rotate(calc(var(--rotation) + 180deg)) translateZ(0);
            }

            100% {
                transform: translate(var(--start-x), var(--start-y)) rotate(calc(var(--rotation) + 360deg)) translateZ(0);
            }
        }

        .container {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 20px;
        }

        .countdown {
            font-size: 80px;
            font-weight: bold;
            font-family: 'AzeretMono', monospace;
            text-shadow:
                0 2px 8px rgba(0, 0, 0, 0.8),
                0 4px 16px rgba(0, 0, 0, 0.6);
            animation: pulse 1s ease-in-out infinite;
            transition: all 0.3s ease;
            position: relative;
            display: inline-block;
        }

        .milliseconds {
            position: absolute;
            bottom: 0;
            right: -65px;
            font-size: 24px;
            font-weight: normal;
            color: inherit;
            opacity: 0.6;
            text-shadow: inherit;
            font-family: 'AzeretMono', monospace;
        }

        .countdown.warning,
        .countdown.warning .milliseconds {
            color: #ff9500;
            animation: pulse 0.5s ease-in-out infinite, shake 0.5s ease-in-out infinite;
        }

        .countdown.danger,
        .countdown.danger .milliseconds {
            color: #ff3b30;
            animation: pulse 0.3s ease-in-out infinite, shake 0.3s ease-in-out infinite;
        }

        @keyframes pulse {

            0%,
            100% {
                transform: scale(1);
            }

            50% {
                transform: scale(1.05);
            }
        }

        @keyframes shake {

            0%,
            100% {
                transform: translateX(0) scale(1);
            }

            25% {
                transform: translateX(-5px) scale(1.05);
            }

            75% {
                transform: translateX(5px) scale(1.05);
            }
        }

        .overtime {
            font-size: 60px;
            font-weight: bold;
            font-family: 'AzeretMono', monospace;
            color: #ff3b30;
            text-shadow:
                0 2px 8px rgba(0, 0, 0, 0.8),
                0 4px 16px rgba(0, 0, 0, 0.6);
            animation: blink 0.5s ease-in-out infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.7;
            }
        }

        .hidden {
            opacity: 0;
            visibility: hidden;
            pointer-events: none;
            transition: opacity 0.3s ease, visibility 0s linear 0.3s;
        }

        .visible {
            opacity: 1;
            visibility: visible;
            pointer-events: auto;
            transition: opacity 0.3s ease, visibility 0s linear 0s;
        }

        /* Indicateur de connexion */
        .connection-status {
            position: fixed;
            top: 10px;
            right: 10px;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            font-family: 'Poppins', sans-serif;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 6px;
            transition: all 0.3s ease;
        }

        .connection-status.connected {
            background: rgba(0, 255, 0, 0.2);
            border: 1px solid rgba(0, 255, 0, 0.4);
            color: #00ff00;
        }

        .connection-status.disconnected {
            background: rgba(255, 0, 0, 0.2);
            border: 1px solid rgba(255, 0, 0, 0.4);
            color: #ff6666;
        }

        .connection-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: currentColor;
            animation: pulse-dot 2s ease-in-out infinite;
        }

        @keyframes pulse-dot {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }
        }
    </style>
</head>

<body>
    <div class="connection-status disconnected"
         id="connectionStatus">
        <div class="connection-dot"></div>
        <span>Connexion...</span>
    </div>

    <div class="ratio-wrapper">
        <!-- Bordure SVG progressive -->
        <svg class="progress-border-svg"
             id="borderSvg"
             viewBox="0 0 1000 562.5"
             preserveAspectRatio="none">
            <defs>
                <!-- Gradients -->
                <linearGradient id="gradientNormal"
                                x1="0%"
                                y1="0%"
                                x2="100%"
                                y2="0%">
                    <stop offset="0%"
                          style="stop-color:#5a2d81;stop-opacity:1" />
                    <stop offset="100%"
                          style="stop-color:#7b3f9e;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="gradientWarning"
                                x1="0%"
                                y1="0%"
                                x2="100%"
                                y2="0%">
                    <stop offset="0%"
                          style="stop-color:#ff9500;stop-opacity:1" />
                    <stop offset="100%"
                          style="stop-color:#ffcc00;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="gradientDanger"
                                x1="0%"
                                y1="0%"
                                x2="100%"
                                y2="0%">
                    <stop offset="0%"
                          style="stop-color:#ff0000;stop-opacity:1" />
                    <stop offset="100%"
                          style="stop-color:#ff3333;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="gradientOvertime"
                                x1="0%"
                                y1="0%"
                                x2="100%"
                                y2="0%">
                    <stop offset="0%"
                          style="stop-color:#ff0000;stop-opacity:1" />
                    <stop offset="100%"
                          style="stop-color:#ff00ff;stop-opacity:1" />
                </linearGradient>
            </defs>

            <!-- Bordure de fond (toujours complète, opacité fixe 15%) -->
            <rect id="borderBackground"
                  x="2"
                  y="2"
                  width="996"
                  height="558.5"
                  stroke="url(#gradientNormal)"
                  style="opacity: 0.15;" />

            <!-- Bordure animée (se vide progressivement) -->
            <rect id="borderRect"
                  x="2"
                  y="2"
                  width="996"
                  height="558.5"
                  stroke="url(#gradientNormal)" />
        </svg>

        <div class="main-content">
            <!-- Dégradé animé avec vagues fluides -->
            <div class="waves-container"
                 id="wavesContainer">
                <div class="gradient"></div>
                <div class="gradient"></div>
                <div class="gradient"></div>
            </div>

            <div class="container">
                <div class="countdown hidden"
                     id="countdown">
                    60
                    <span class="milliseconds hidden"
                          id="milliseconds">.000</span>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Initialiser Firebase
        firebase.initializeApp(firebaseConfig);
        const database = firebase.database();
        const gameRef = database.ref('game');
        const configRef = database.ref('config');

        // Éléments du DOM
        const countdownElement = document.getElementById('countdown');
        const millisecondsElement = document.getElementById('milliseconds');
        const borderSvg = document.getElementById('borderSvg');
        const borderRect = document.getElementById('borderRect');
        const connectionStatus = document.getElementById('connectionStatus');

        // Variables d'état
        let isRunning = false;
        let isPaused = false;
        let isStopped = true;
        let startTime = 0;
        let pauseTime = 0;
        let totalPausedTime = 0;
        let lastSecond = -1;
        let timerInterval = null;

        // Configuration dynamique
        let currentConfig = {
            countdownDuration: CONFIG.countdownDuration || 60,
            warningThreshold: CONFIG.warningThreshold || 10,
            dangerThreshold: CONFIG.dangerThreshold || 5,
            waitingScreenMode: CONFIG.waitingScreenMode || false,
            showBackgroundImage: CONFIG.showBackgroundImage !== undefined ? CONFIG.showBackgroundImage : true,
            numberOfGradients: CONFIG.numberOfGradients !== undefined ? CONFIG.numberOfGradients : 5,
            gradientSpeed: CONFIG.gradientSpeed || 30,
            gradientSize: CONFIG.gradientSize || 300,
            gradientOpacity: CONFIG.gradientOpacity !== undefined ? CONFIG.gradientOpacity : 0.12
        };

        // Fonction pour appliquer les paramètres visuels
        function applyVisualConfig() {
            // Appliquer l'image de fond sur la zone 16:9
            const ratioWrapper = document.querySelector('.ratio-wrapper');
            if (currentConfig.showBackgroundImage) {
                ratioWrapper.classList.add('show-background');
            } else {
                ratioWrapper.classList.remove('show-background');
            }

            // Appliquer les lueurs
            const wavesContainer = document.getElementById('wavesContainer');
            const existingGradients = wavesContainer.querySelectorAll('.gradient');

            // Ajuster le nombre de gradients
            const currentCount = existingGradients.length;
            const targetCount = currentConfig.numberOfGradients;

            if (currentCount < targetCount) {
                // Ajouter des gradients
                for (let i = currentCount; i < targetCount; i++) {
                    const gradient = document.createElement('div');
                    gradient.className = 'gradient';
                    wavesContainer.appendChild(gradient);
                }
            } else if (currentCount > targetCount) {
                // Retirer des gradients en trop
                for (let i = currentCount - 1; i >= targetCount; i--) {
                    existingGradients[i].remove();
                }
            }

            // Appliquer les propriétés CSS à tous les gradients avec positions aléatoires
            const allGradients = wavesContainer.querySelectorAll('.gradient');
            allGradients.forEach((gradient, index) => {
                gradient.style.setProperty('--size', currentConfig.gradientSize + 'px');
                gradient.style.setProperty('--speed', currentConfig.gradientSpeed + 's');
                gradient.style.opacity = currentConfig.gradientOpacity;

                // Positions aléatoires pour l'animation
                const startX = (Math.random() - 0.5) * 60; // -30vw à +30vw
                const startY = (Math.random() - 0.5) * 40; // -20vh à +20vh
                const endX = (Math.random() - 0.5) * 60;
                const endY = (Math.random() - 0.5) * 40;
                const rotation = Math.random() * 360;
                const delay = -Math.random() * currentConfig.gradientSpeed;

                gradient.style.setProperty('--start-x', startX + 'vw');
                gradient.style.setProperty('--start-y', startY + 'vh');
                gradient.style.setProperty('--end-x', endX + 'vw');
                gradient.style.setProperty('--end-y', endY + 'vh');
                gradient.style.setProperty('--rotation', rotation + 'deg');
                gradient.style.animationDelay = delay + 's';
            });
        }

        // Appliquer la configuration initiale
        applyVisualConfig();

        // Calculer le périmètre du rectangle pour stroke-dasharray
        const rectPerimeter = 2 * (996 + 558.5);
        borderRect.style.strokeDasharray = rectPerimeter;
        borderRect.style.strokeDashoffset = 0;

        // S'assurer que la bordure est visible au démarrage
        borderSvg.classList.remove('fade-out');

        // Surveiller la connexion Firebase
        const connectedRef = database.ref('.info/connected');
        connectedRef.on('value', (snap) => {
            if (snap.val() === true) {
                connectionStatus.className = 'connection-status connected';
                connectionStatus.querySelector('span').textContent = 'Connecté';

                // Masquer après 2 secondes
                setTimeout(() => {
                    connectionStatus.style.display = 'none';
                }, 2000);
            } else {
                connectionStatus.className = 'connection-status disconnected';
                connectionStatus.querySelector('span').textContent = 'Déconnecté';
                connectionStatus.style.display = 'flex';
            }
        });

        // Écouter les changements de configuration
        configRef.on('value', (snapshot) => {
            const config = snapshot.val();
            if (config) {
                console.log('Configuration updated:', config);
                currentConfig = {
                    countdownDuration: config.countdownDuration || 60,
                    warningThreshold: config.warningThreshold || 10,
                    dangerThreshold: config.dangerThreshold || 5,
                    waitingScreenMode: config.waitingScreenMode || false,
                    showBackgroundImage: config.showBackgroundImage !== undefined ? config.showBackgroundImage : true,
                    numberOfGradients: config.numberOfGradients !== undefined ? config.numberOfGradients : 5,
                    gradientSpeed: config.gradientSpeed || 30,
                    gradientSize: config.gradientSize || 300,
                    gradientOpacity: config.gradientOpacity !== undefined ? config.gradientOpacity : 0.12
                };

                // Appliquer les paramètres visuels
                applyVisualConfig();

                // Si le timer est arrêté, mettre à jour l'affichage
                if (isStopped) {
                    if (currentConfig.waitingScreenMode) {
                        const minutes = Math.floor(currentConfig.countdownDuration / 60);
                        const seconds = currentConfig.countdownDuration % 60;
                        countdownElement.textContent = `${minutes}:${String(seconds).padStart(2, '0')}`;
                    } else {
                        countdownElement.textContent = currentConfig.countdownDuration;
                    }
                }
            }
        });

        // Écouter les changements d'état depuis Firebase
        gameRef.on('value', (snapshot) => {
            const data = snapshot.val();
            if (!data) return;

            console.log('Firebase update:', data);

            // Restaurer l'état après F5
            if (data.isRunning && !isRunning && data.startTime) {
                console.log('Restoring game state after reload');
                isRunning = true;
                isStopped = false;
                isPaused = data.isPaused || false;
                startTime = data.startTime;
                totalPausedTime = data.totalPausedTime || 0;
                if (data.isPaused && data.pauseTime) {
                    pauseTime = data.pauseTime;
                }

                document.body.classList.remove('game-over');
                borderSvg.classList.remove('fade-out');
                countdownElement.classList.remove('hidden');
                countdownElement.classList.add('visible');

                if (timerInterval) clearInterval(timerInterval);
                timerInterval = setInterval(updateTimer, 16);
            }

            if (data.command === 'start' && !isRunning) {
                startGame();
            } else if (data.command === 'pause' && isRunning && !isPaused) {
                pauseGame();
            } else if (data.command === 'resume' && isPaused) {
                resumeGame();
            } else if (data.command === 'stop') {
                stopGame();
            } else if (data.command === 'reset') {
                resetGame();
            }
        });

        function startGame() {
            console.log('Starting game');
            isRunning = true;
            isStopped = false;
            isPaused = false;
            startTime = Date.now();
            totalPausedTime = 0;
            lastSecond = -1;

            document.body.classList.remove('game-over');
            borderSvg.classList.remove('fade-out');
            countdownElement.classList.remove('hidden');
            countdownElement.classList.add('visible');
            countdownElement.classList.remove('blink-mode');

            if (timerInterval) clearInterval(timerInterval);
            timerInterval = setInterval(updateTimer, 16);
        }

        function pauseGame() {
            console.log('Pausing game');
            isPaused = true;
            pauseTime = Date.now();
        }

        function resumeGame() {
            console.log('Resuming game');
            isPaused = false;
            const pauseDuration = Date.now() - pauseTime;
            totalPausedTime += pauseDuration;
        }

        function stopGame() {
            console.log('Stopping game');
            isRunning = false;
            isPaused = false;
            isStopped = true;
            clearInterval(timerInterval);

            document.body.classList.add('game-over');
            borderSvg.classList.add('fade-out');
        }

        function resetGame() {
            console.log('Resetting game');
            stopGame();

            // Masquer le compteur avec opacity
            millisecondsElement.classList.remove('visible');
            millisecondsElement.classList.add('hidden');
            countdownElement.classList.remove('visible');
            countdownElement.classList.add('hidden');

            countdownElement.className = 'countdown hidden';
            countdownElement.classList.remove('blink-mode');

            borderRect.classList.remove('overtime');
            borderSvg.classList.add('fade-out');
            borderRect.setAttribute('stroke', 'url(#gradientNormal)');
            borderRect.style.strokeDashoffset = 0;

            document.body.classList.remove('game-over');
        }

        function updateBorders(percentage, state) {
            const dashOffset = state === 'overtime' ? 0 : rectPerimeter * (1 - percentage / 100);
            borderRect.style.strokeDashoffset = dashOffset;

            if (state === 'overtime') {
                borderRect.setAttribute('stroke', 'url(#gradientOvertime)');
                borderRect.classList.add('overtime');
            } else if (state === 'danger') {
                borderRect.setAttribute('stroke', 'url(#gradientDanger)');
                borderRect.classList.remove('overtime');
            } else if (state === 'warning') {
                borderRect.setAttribute('stroke', 'url(#gradientWarning)');
                borderRect.classList.remove('overtime');
            } else {
                borderRect.setAttribute('stroke', 'url(#gradientNormal)');
                borderRect.classList.remove('overtime');
            }
        }

        function updateTimer() {
            if (!isRunning || isPaused) return;

            const now = Date.now();
            const elapsed = now - startTime - totalPausedTime;
            const totalSeconds = elapsed / 1000;

            if (totalSeconds < currentConfig.countdownDuration) {
                const remaining = currentConfig.countdownDuration - totalSeconds;
                const displayValue = currentConfig.waitingScreenMode ? Math.max(0, Math.ceil(remaining)) : Math.max(1, Math.ceil(remaining));
                const percentage = (remaining / currentConfig.countdownDuration) * 100;

                if (currentConfig.waitingScreenMode) {
                    const totalSecondsRemaining = Math.floor(remaining);
                    const minutes = Math.floor(totalSecondsRemaining / 60);
                    const seconds = totalSecondsRemaining % 60;
                    countdownElement.textContent = `${minutes}:${String(seconds).padStart(2, '0')}`;
                    millisecondsElement.classList.add('hidden');
                    millisecondsElement.classList.remove('visible');

                    if (totalSecondsRemaining <= currentConfig.dangerThreshold && totalSecondsRemaining > 0) {
                        countdownElement.className = 'countdown danger';
                        updateBorders(percentage, 'danger');
                    } else if (totalSecondsRemaining <= currentConfig.warningThreshold && totalSecondsRemaining > 0) {
                        countdownElement.className = 'countdown warning';
                        updateBorders(percentage, 'warning');
                    } else if (totalSecondsRemaining > 0) {
                        countdownElement.className = 'countdown';
                        updateBorders(percentage, '');
                    }

                    if (totalSecondsRemaining === 0 && lastSecond !== 0) {
                        countdownElement.classList.add('blink-mode');
                        borderRect.classList.add('blink-mode');
                        const wavesContainer = document.getElementById('wavesContainer');
                        if (wavesContainer) {
                            wavesContainer.querySelectorAll('.gradient').forEach(g => g.classList.add('blink-mode'));
                        }
                        lastSecond = 0;
                    }
                } else {
                    const milliseconds = Math.floor((remaining - Math.floor(remaining)) * 1000);
                    millisecondsElement.textContent = `.${String(milliseconds).padStart(3, '0')}`;
                    millisecondsElement.classList.remove('hidden');
                    millisecondsElement.classList.add('visible');

                    if (displayValue > 60) {
                        const minutes = Math.floor(displayValue / 60);
                        const seconds = displayValue % 60;
                        countdownElement.textContent = `${minutes}:${String(seconds).padStart(2, '0')}`;
                    } else {
                        countdownElement.textContent = displayValue;
                    }

                    lastSecond = displayValue;

                    if (displayValue <= currentConfig.dangerThreshold) {
                        countdownElement.className = 'countdown danger';
                        updateBorders(percentage, 'danger');
                    } else if (displayValue <= currentConfig.warningThreshold) {
                        countdownElement.className = 'countdown warning';
                        updateBorders(percentage, 'warning');
                    } else {
                        countdownElement.className = 'countdown';
                        updateBorders(percentage, '');
                    }
                }
            } else {
                const overtimeSeconds = totalSeconds - currentConfig.countdownDuration;

                if (Math.floor(overtimeSeconds) === 0 && lastSecond !== -999) {
                    lastSecond = -999;
                }

                updateBorders(0, 'overtime');

                // Garder le texte au même endroit (dans countdownElement)
                countdownElement.className = 'countdown danger';
                countdownElement.classList.remove('hidden');
                countdownElement.classList.add('visible');
                millisecondsElement.classList.add('hidden');
                millisecondsElement.classList.remove('visible');

                const overtimeMinutes = Math.floor(overtimeSeconds / 60);
                const overtimeSecs = Math.floor(overtimeSeconds % 60);
                if (overtimeMinutes > 0) {
                    countdownElement.textContent = `+${overtimeMinutes}min ${overtimeSecs}`;
                } else {
                    countdownElement.textContent = `+${overtimeSecs}`;
                }
            }
        }

        // Initialiser l'affichage
        if (currentConfig.waitingScreenMode) {
            const minutes = Math.floor(currentConfig.countdownDuration / 60);
            const seconds = currentConfig.countdownDuration % 60;
            countdownElement.textContent = `${minutes}:${String(seconds).padStart(2, '0')}`;
        } else {
            countdownElement.textContent = currentConfig.countdownDuration;
        }
    </script>
</body>

</html>